# UX Heuristics

## Nielsen's 10 Usability Heuristics

### 1. Visibility of system status
The system should always keep users informed about what is going on,
through appropriate feedback within reasonable time.
**Check for**: Loading states, progress indicators, confirmation messages, empty states.

### 2. Match between system and the real world
Use language and concepts familiar to the user, not system-oriented terms.
Follow real-world conventions and present information in a natural order.
**Check for**: Jargon, technical IDs shown to users, unintuitive ordering.

### 3. User control and freedom
Users often make mistakes. Provide clearly marked "emergency exits" —
undo, cancel, back — without requiring an extended process.
**Check for**: Missing back buttons, no undo, irreversible actions without warning.

### 4. Consistency and standards
Users shouldn't have to wonder whether different words, situations, or
actions mean the same thing. Follow platform and product conventions.
**Check for**: Inconsistent terminology, different patterns for same action, broken conventions.

### 5. Error prevention
Even better than good error messages is a careful design which prevents
problems from occurring in the first place.
**Check for**: Confirmation for destructive actions, constraints that prevent invalid input, smart defaults.

### 6. Recognition rather than recall
Minimize the user's memory load. Make objects, actions, and options visible.
Instructions should be visible or easily retrievable.
**Check for**: Hidden navigation, information users must remember between screens, unclear icons without labels.

### 7. Flexibility and efficiency of use
Shortcuts — unseen by novice users — speed up interaction for experts.
Allow users to tailor frequent actions.
**Check for**: Keyboard shortcuts, bulk actions, customizable workflows, power-user paths.

### 8. Aesthetic and minimalist design
Every extra unit of information competes with relevant information and
diminishes its relative visibility.
**Check for**: Visual clutter, redundant elements, content that doesn't serve the user's current task.

### 9. Help users recognize, diagnose, and recover from errors
Error messages should be in plain language, precisely indicate the problem,
and constructively suggest a solution.
**Check for**: Cryptic error codes, messages that blame the user, errors without recovery paths.

### 10. Help and documentation
Even though it's better if the system can be used without documentation,
help should be easy to search, focused on the task, and list concrete steps.
**Check for**: Missing help, no contextual guidance, documentation that's separate from the interface.

## Shneiderman's 8 Golden Rules

1. **Strive for consistency** — same sequences of actions for similar situations
2. **Seek universal usability** — cater to novices and experts alike
3. **Offer informative feedback** — every action gets a response
4. **Design dialogs to yield closure** — sequences have beginning, middle, end
5. **Prevent errors** — design so errors are hard to make
6. **Permit easy reversal of actions** — reduces anxiety, encourages exploration
7. **Keep users in control** — they initiate actions, not the system
8. **Reduce short-term memory load** — keep displays simple, consolidate pages
